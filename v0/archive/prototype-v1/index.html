<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Island Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            min-height: 100vh;
            margin: 0;
            background-image: url('bg.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed;
            position: relative;
        }
        
        .character-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-width: 200px;
            text-align: left;
            cursor: pointer;
            transition: box-shadow 0.2s;
        }
        
        .character-panel:hover {
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .character-panel.active-turn {
            box-shadow: 0 0 0 3px #4CAF50;
        }
        
        .character-panel-2 {
            position: absolute;
            top: 20px;
            left: 280px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-width: 200px;
            text-align: left;
            display: none;
            cursor: pointer;
            transition: box-shadow 0.2s;
        }
        
        .character-panel-2:hover {
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .character-panel-2.active-turn {
            box-shadow: 0 0 0 3px #4CAF50;
        }
        
        .character-panel-2.show {
            display: block;
        }
        
        .ap-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #FF9800;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .ap-indicator.spent {
            background-color: #9E9E9E;
        }
        
        .add-player-btn {
            position: absolute;
            top: 110px;
            left: 252px;
            width: 30px;
            height: 30px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            line-height: 1;
            padding: 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .add-player-btn:hover {
            background: #45a049;
        }
        
        .add-player-btn.hidden {
            display: none;
        }
        
        .link-btn {
            position: absolute;
            top: 105px;
            left: 248px;
            width: 40px;
            height: 40px;
            background: transparent !important;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 32px;
            line-height: 1;
            padding: 0;
            display: none;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s;
            z-index: 10;
        }
        
        .link-btn.show {
            display: flex;
        }
        
        .link-btn:hover {
            transform: scale(1.2);
            background: transparent !important;
        }
        
        .link-btn:focus {
            outline: none;
            background: transparent !important;
        }
        
        .link-btn:active {
            background: transparent !important;
        }
        
        .link-btn.unlinked {
            opacity: 0;
        }
        
        .link-btn.unlinked:hover {
            opacity: 0.4;
            transform: scale(1.2);
        }
        
        .link-btn.disabled {
            opacity: 0.2 !important;
        }
        
        .link-btn.disabled:hover {
            opacity: 0.2 !important;
            transform: none;
        }
        
        .character-panel h2,
        .character-panel-2 h2 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .tired-indicator {
            font-size: 20px;
            display: none;
        }
        
        .tired-indicator.show {
            display: inline;
        }
        
        .character-panel h2:hover,
        .character-panel-2 h2:hover {
            color: #4CAF50;
        }
        
        .character-panel input.name-edit,
        .character-panel-2 input.name-edit {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 18px;
            font-weight: bold;
            border: 2px solid #4CAF50;
            padding: 4px;
            border-radius: 4px;
            width: 100%;
            box-sizing: border-box;
        }
        
        .character-panel p,
        .character-panel-2 p {
            margin: 8px 0;
            color: #555;
        }
        
        
        .food-card {
            position: absolute;
            top: 230px;
            left: 20px;
            background: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-width: 200px;
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: center;
            gap: 10px;
        }
        
        .food-text {
            color: #555;
            font-weight: bold;
        }
        
        .eat-circle {
            padding: 5px 10px;
            background-color: #FF9800;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            width: fit-content;
        }
        
        .eat-circle:hover:not(:disabled) {
            background-color: #F57C00;
        }
        
        .eat-circle:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .day-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-size: 20px;
            font-weight: bold;
            color: #333;
        }
        
        .map-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: box-shadow 0.3s;
        }
        
        .map-panel.exploring {
            box-shadow: 0 0 0 4px gold;
        }
        
        .moves-remaining {
            position: absolute;
            top: 550px;
            right: 275px;
            transform: translateX(50%);
            text-align: center;
            font-weight: bold;
            color: #333;
            background: white;
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .map-key {
            position: absolute;
            top: 550px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-size: 14px;
        }
        
        .map-key-title {
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
        }
        
        .map-key-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            color: #555;
        }
        
        .map-key-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 8px;
            font-weight: bold;
            font-size: 12px;
        }
        
        .map-key-icon.player {
            background-color: white;
            outline: 3px solid #d95555;
            outline-offset: -3px;
        }
        
        .map-key-icon.player2 {
            background-color: white;
            outline: 3px solid #29496b;
            outline-offset: -3px;
        }
        
        .map-key-icon.berry {
            background-color: #a8326d;
            color: white;
        }
        
        .map-key-icon.shelter {
            background-color: #8B4513;
            color: white;
        }
        
        .map-key-icon.natural-shelter {
            background-color: #8B4513;
            color: black;
        }
        
        .map-grid {
            display: grid;
            grid-template-columns: repeat(16, 30px);
            grid-template-rows: repeat(16, 30px);
            gap: 0px;
        }
        
        .map-tile {
            background-color: #424242;
            border: 1px solid #999;
            position: relative;
        }
        
        .map-tile.fogged {
            background-color: #424242;
        }
        
        .map-tile.seen-beach {
            background-color: #8f816f;
        }
        
        .map-tile.revealed-beach {
            background-color: #e6d1b5;
        }
        
        .map-tile.seen-grass {
            background-color: #244f27;
        }
        
        .map-tile.revealed-grass {
            background-color: #4ea354;
        }
        
        .map-tile.seen-water {
            background-color: #4a90e2;
        }
        
        .map-tile.clickable-adjacent:hover {
            background-color: #87CEEB;
        }
        
        .map-tile.clickable-current:hover {
            background-color: #4682B4;
        }
        
        .player-marker {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 50%;
            height: 50%;
            background-color: #d95555;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 7px;
        }
        
        .shelter-marker {
            position: absolute;
            top: 0;
            left: 0;
            width: 50%;
            height: 50%;
            background-color: #8B4513;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 7px;
        }
        
        .natural-shelter-marker {
            position: absolute;
            top: 0;
            left: 0;
            width: 50%;
            height: 50%;
            background-color: #8B4513;
            display: flex;
            align-items: center;
            justify-content: center;
            color: black;
            font-weight: bold;
            font-size: 7px;
        }
        
        .berry-marker {
            position: absolute;
            top: 0;
            right: 0;
            width: 50%;
            height: 50%;
            background-color: #a8326d;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 7px;
        }
        
        .berry-marker.picked {
            background-color: #d4a5ba;
        }
        
        .berry-marker.barren {
            background-color: #888;
        }
        
        .game-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        .container {
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        h1 {
            margin-bottom: 30px;
            color: #333;
        }
        
        button {
            display: block;
            width: 200px;
            padding: 15px;
            margin: 10px auto;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .reset-button {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 10px 20px;
            font-size: 14px;
            background-color: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: auto;
        }
        
        .reset-button:hover {
            background-color: #da190b;
        }
        
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .modal-overlay.active {
            display: flex;
        }
        
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            text-align: center;
            max-width: 400px;
        }
        
        .modal-content p {
            margin: 0 0 20px 0;
            font-size: 18px;
            color: #333;
        }
        
        .modal-content button {
            width: 100px;
            padding: 10px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .modal-content button:hover {
            background-color: #45a049;
        }
        
        .game-over-content {
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            text-align: center;
            max-width: 400px;
        }
        
        .game-over-content h1 {
            margin: 0 0 20px 0;
            font-size: 48px;
            color: #d32f2f;
        }
        
        .game-over-content p {
            margin: 0 0 30px 0;
            font-size: 24px;
            color: #333;
        }
        
        .game-over-content button {
            width: 150px;
            padding: 12px;
            font-size: 18px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .game-over-content button:hover {
            background-color: #45a049;
        }
        
        .tired-content {
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            text-align: center;
            max-width: 500px;
        }
        
        .tired-content h2 {
            margin: 0 0 20px 0;
            font-size: 32px;
            color: #333;
        }
        
        .tired-content p {
            margin: 10px 0;
            font-size: 18px;
            color: #555;
        }
        
        .tired-content button {
            margin-top: 20px;
            width: 100px;
            padding: 10px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .tired-content button:hover {
            background-color: #45a049;
        }
        
        .day-transition-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(25, 25, 112, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1.2s ease-in-out;
        }
        
        .day-transition-overlay.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .day-transition-text {
            color: white;
            font-size: 48px;
            font-weight: bold;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        
        .day-transition-text.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="day-transition-overlay" id="day-transition-overlay">
        <div class="day-transition-text" id="day-transition-text">Day 1</div>
    </div>
    <div class="character-panel" id="character-panel-1">
        <div class="ap-indicator" id="ap-indicator-1"></div>
        <h2 id="player-name"><span class="name-text">Albert</span><span class="tired-indicator" id="tired-indicator-1">ü•±</span></h2>
        <p id="hp-display">HP: 4</p>
        <p id="fp-display">FP: 4</p>
        <p id="item1-display">Item 1: none</p>
        <p id="item2-display">Item 2: none</p>
        <p id="item3-display">Item 3: none</p>
    </div>
    
    <button class="add-player-btn" id="add-player-btn">+</button>
    
    <button class="link-btn" id="link-btn" title="Link/Unlink players">üîó</button>
    
    <div class="character-panel-2" id="character-panel-2">
        <div class="ap-indicator" id="ap-indicator-2"></div>
        <h2 id="player-name-2"><span class="name-text">Bio</span><span class="tired-indicator" id="tired-indicator-2">ü•±</span></h2>
        <p id="hp-display-2">HP: 4</p>
        <p id="fp-display-2">FP: 4</p>
        <p id="item1-display-2">Item 1: none</p>
        <p id="item2-display-2">Item 2: none</p>
        <p id="item3-display-2">Item 3: none</p>
    </div>
    
    <div class="food-card">
        <span class="food-text" id="food-text">Food: 0</span>
        <button class="eat-circle" id="eat-circle">Eat</button>
    </div>
    
    <div class="day-display" id="day-display">Day 1</div>
    
    <div class="map-panel" id="map-panel">
        <div class="map-grid" id="map-grid"></div>
    </div>
    <div class="moves-remaining" id="moves-remaining" style="display: none;"></div>
    
    <div class="map-key">
        <div class="map-key-title">Key:</div>
        <div class="map-key-item">
            <div class="map-key-icon player"></div>
            <span id="map-key-name-1">Albert</span>
        </div>
        <div class="map-key-item" id="player2-key" style="display: none;">
            <div class="map-key-icon player2"></div>
            <span id="map-key-name-2">Bio</span>
        </div>
        <div class="map-key-item">
            <div class="map-key-icon berry">‚óè</div>
            <span>Berry Bush</span>
        </div>
        <div class="map-key-item">
            <div class="map-key-icon natural-shelter">‚ñ≤</div>
            <span>Natural Shelter</span>
        </div>
        <div class="map-key-item">
            <div class="map-key-icon shelter">‚ñ≤</div>
            <span>Built Shelter</span>
        </div>
    </div>
    
    <button class="reset-button" id="reset-button">Reset Game</button>
    
    <div class="game-container">
        <div class="container">
            <h1>Today's activity?</h1>
            <p id="current-player-display" style="margin-top: -15px; margin-bottom: 20px; color: #666; font-size: 18px;"></p>
            <button id="build-shelter">1. Build Shelter</button>
            <button id="gather-food">2. Gather Food</button>
            <button id="explore">3. Explore</button>
        </div>
    </div>
    
    <div class="modal-overlay" id="modal-overlay">
        <div class="modal-content">
            <p id="modal-message"></p>
            <button id="modal-ok">Ok</button>
        </div>
    </div>
    
    <div class="modal-overlay" id="game-over-overlay">
        <div class="game-over-content">
            <h1>Game Over</h1>
            <p>You've died!</p>
            <button id="try-again">Try Again</button>
        </div>
    </div>
    
    <div class="modal-overlay" id="tired-overlay">
        <div class="tired-content">
            <h2>You slept like shit.</h2>
            <p>Status gained: Tired</p>
            <p>Movement penalty: -1</p>
            <button id="tired-ok">Ok</button>
            <p>(Sleep in a shelter to avoid this.)</p>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        // Import Firebase SDK
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js';
        import { getDatabase, ref, set, onValue, update, get } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-database.js';
        
        // Firebase configuration - you'll need to add your Firebase project details here
        // To get these values:
        // 1. Go to https://console.firebase.google.com/
        // 2. Create a new project (or use existing)
        // 3. Go to Project Settings > Your apps > Web app
        // 4. Copy the config object
        const firebaseConfig = {
            apiKey: "YOUR_API_KEY_HERE",
            authDomain: "YOUR_PROJECT.firebaseapp.com",
            databaseURL: "https://YOUR_PROJECT.firebaseio.com",
            projectId: "YOUR_PROJECT_ID",
            storageBucket: "YOUR_PROJECT.appspot.com",
            messagingSenderId: "YOUR_MESSAGING_ID",
            appId: "YOUR_APP_ID"
        };
        
        // Initialize Firebase (commented out until you add your config)
        // const app = initializeApp(firebaseConfig);
        // const database = getDatabase(app);
        
        // Make Firebase available to the main script
        window.firebaseApp = null; // Will be set when you add config
        window.firebaseDatabase = null; // Will be set when you add config
        window.firebaseReady = false;
    </script>

    <script>
        // Character model
        const character = {
            name: "Albert",
            hp: 4,
            fp: 4,
            inventory: [null, null, null],
            position: { row: 15, col: 0 }, // Bottom left (0-indexed, row 15 = bottom)
            tired: false,
            ap: 1 // Action points
        };
        
        // Second character model
        const character2 = {
            name: "Bio",
            hp: 4,
            fp: 4,
            inventory: [null, null, null],
            position: { row: 15, col: 0 }, // Will be set when player 2 is added
            tired: false,
            active: false, // Track if second player is active
            ap: 1 // Action points
        };

        // Game state
        const gameState = {
            day: 1,
            mapSize: 16, // 16x16 grid
            visitedTiles: new Set(), // Track which tiles have been visited (revealed)
            seenTiles: new Set(), // Track which tiles the player has seen (but maybe not visited)
            landTiles: new Set(), // Track which tiles are land vs water
            shelters: new Set(), // Track which tiles have built shelters
            naturalShelters: new Set(), // Track which tiles have natural shelters
            berryBushes: new Map(), // Track berry bushes and their states: 'full', 'picked', 'barren1', 'barren2'
            bushesGatheredToday: new Set(), // Track which bushes were gathered from today
            isExploring: false,
            movesRemaining: 0,
            food: 0, // Food storage (not part of character)
            hasSeenTiredMessage: false, // Track if player has seen tired message this game
            playersLinked: true, // Track if players are linked (move together) or separate
            currentTurn: 1 // Track whose turn it is (1 or 2)
        };
        
        // Helper function to create a tile key
        function getTileKey(row, col) {
            return `${row},${col}`;
        }
        
        // Random seed for island generation
        let islandSeed = Math.random() * 100000;
        
        // Simple noise function
        function simpleNoise(x, y) {
            const n = Math.sin(x * 12.9898 + y * 78.233 + islandSeed) * 43758.5453;
            return (n - Math.floor(n)) * 2 - 1;
        }
        
        // Multi-octave noise for more natural terrain
        function multiOctaveNoise(x, y) {
            let value = 0;
            let amplitude = 1;
            let frequency = 1;
            
            for (let i = 0; i < 3; i++) {
                value += simpleNoise(x * frequency, y * frequency) * amplitude;
                amplitude *= 0.5;
                frequency *= 2;
            }
            
            return value / 1.75; // Normalize
        }
        
        // Flood fill to find connected land tiles
        function floodFill(startKey, landTiles) {
            const visited = new Set();
            const queue = [startKey];
            visited.add(startKey);
            
            while (queue.length > 0) {
                const current = queue.shift();
                const [row, col] = current.split(',').map(Number);
                
                // Check all 4 cardinal directions (not diagonals for island connection)
                const neighbors = [
                    [row - 1, col],
                    [row + 1, col],
                    [row, col - 1],
                    [row, col + 1]
                ];
                
                for (const [nRow, nCol] of neighbors) {
                    if (nRow >= 0 && nRow < gameState.mapSize && nCol >= 0 && nCol < gameState.mapSize) {
                        const neighborKey = getTileKey(nRow, nCol);
                        if (landTiles.has(neighborKey) && !visited.has(neighborKey)) {
                            visited.add(neighborKey);
                            queue.push(neighborKey);
                        }
                    }
                }
            }
            
            return visited;
        }
        
        // Find the largest connected landmass
        function findLargestIsland(landTiles) {
            const allLand = new Set(landTiles);
            let largestIsland = new Set();
            
            while (allLand.size > 0) {
                const startKey = allLand.values().next().value;
                const island = floodFill(startKey, landTiles);
                
                if (island.size > largestIsland.size) {
                    largestIsland = island;
                }
                
                // Remove this island from consideration
                for (const tile of island) {
                    allLand.delete(tile);
                }
            }
            
            return largestIsland;
        }
        
        // Fill interior water holes (lakes) to make solid island
        function fillInteriorWater(landTiles) {
            const waterTiles = new Set();
            
            // Find all water tiles
            for (let row = 0; row < gameState.mapSize; row++) {
                for (let col = 0; col < gameState.mapSize; col++) {
                    const key = getTileKey(row, col);
                    if (!landTiles.has(key)) {
                        waterTiles.add(key);
                    }
                }
            }
            
            // Find water connected to edges (ocean)
            const oceanTiles = new Set();
            const edgeWaterTiles = [];
            
            // Collect water tiles on edges
            for (let row = 0; row < gameState.mapSize; row++) {
                for (let col = 0; col < gameState.mapSize; col++) {
                    if (row === 0 || row === gameState.mapSize - 1 || 
                        col === 0 || col === gameState.mapSize - 1) {
                        const key = getTileKey(row, col);
                        if (waterTiles.has(key)) {
                            edgeWaterTiles.push(key);
                        }
                    }
                }
            }
            
            // Flood fill from edge water to find all ocean tiles
            for (const startKey of edgeWaterTiles) {
                if (!oceanTiles.has(startKey)) {
                    const connected = floodFill(startKey, waterTiles);
                    for (const tile of connected) {
                        oceanTiles.add(tile);
                    }
                }
            }
            
            // Any water not connected to ocean is interior - convert to land
            const filledLand = new Set(landTiles);
            for (const waterTile of waterTiles) {
                if (!oceanTiles.has(waterTile)) {
                    filledLand.add(waterTile);
                }
            }
            
            return filledLand;
        }
        
        // Generate island shape using noise
        function generateIsland() {
            const totalTiles = gameState.mapSize * gameState.mapSize;
            const targetLandTiles = Math.floor(totalTiles * 0.8); // 80% land
            
            let attempts = 0;
            const maxAttempts = 10;
            
            while (attempts < maxAttempts) {
                const landTiles = new Set();
                
                // Parameters - scale varies with map size, add randomness
                const noiseScale = 0.15 + Math.random() * 0.1; // 0.15-0.25 (lower for bigger features)
                const threshold = -0.5 - Math.random() * 0.2; // -0.5 to -0.7 (more land)
                const falloffStrength = 0.3 + Math.random() * 0.2; // 0.3-0.5 (varied edge shapes)
                
                for (let row = 0; row < gameState.mapSize; row++) {
                    for (let col = 0; col < gameState.mapSize; col++) {
                        // Skip border tiles - they must always be water
                        if (row === 0 || row === gameState.mapSize - 1 || 
                            col === 0 || col === gameState.mapSize - 1) {
                            continue; // Border is always water
                        }
                        
                        // Get noise value (-1 to 1)
                        const noiseValue = multiOctaveNoise(col * noiseScale, row * noiseScale);
                        
                        // Distance from center (creates circular falloff)
                        const centerX = gameState.mapSize / 2;
                        const centerY = gameState.mapSize / 2;
                        const dx = col - centerX;
                        const dy = row - centerY;
                        const distanceFromCenter = Math.sqrt(dx * dx + dy * dy);
                        const normalizedDistance = distanceFromCenter / (gameState.mapSize / 2);
                        
                        // Combine noise with radial gradient
                        const heightValue = noiseValue - (normalizedDistance * falloffStrength);
                        
                        // If above threshold, it's land
                        if (heightValue > threshold) {
                            landTiles.add(getTileKey(row, col));
                        }
                    }
                }
                
                // Keep only the largest connected island
                const largestIsland = findLargestIsland(landTiles);
                
                // Fill any interior water pockets/holes
                const solidIsland = fillInteriorWater(largestIsland);
                
                // Check if we have enough land (at least 65% of target - more lenient)
                if (solidIsland.size >= targetLandTiles * 0.65) {
                    return solidIsland;
                }
                
                attempts++;
            }
            
            // Fallback: create a simple circular island if generation failed
            const fallbackIsland = new Set();
            const center = gameState.mapSize / 2;
            const radius = gameState.mapSize * 0.4; // Smaller to avoid edges
            
            for (let row = 0; row < gameState.mapSize; row++) {
                for (let col = 0; col < gameState.mapSize; col++) {
                    // Skip borders
                    if (row === 0 || row === gameState.mapSize - 1 || 
                        col === 0 || col === gameState.mapSize - 1) {
                        continue;
                    }
                    
                    const dx = col - center;
                    const dy = row - center;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < radius) {
                        fallbackIsland.add(getTileKey(row, col));
                    }
                }
            }
            
            // Fill any interior water holes in fallback too
            return fillInteriorWater(fallbackIsland);
        }
        
        // Initialize natural shelters randomly (20-25% of land tiles)
        function initializeNaturalShelters() {
            gameState.naturalShelters.clear();
            const allLandTiles = [];
            
            // Create array of all land tiles only
            for (let row = 0; row < gameState.mapSize; row++) {
                for (let col = 0; col < gameState.mapSize; col++) {
                    const tileKey = getTileKey(row, col);
                    if (gameState.landTiles.has(tileKey)) {
                        allLandTiles.push(tileKey);
                    }
                }
            }
            
            // Calculate 20-25% of land tiles
            const shelterPercentage = 0.2 + Math.random() * 0.05; // 0.2 to 0.25
            const numShelters = Math.floor(allLandTiles.length * shelterPercentage);
            
            // Randomly select land tiles for natural shelters
            const shelterCount = Math.min(numShelters, allLandTiles.length);
            for (let i = 0; i < shelterCount && allLandTiles.length > 0; i++) {
                const randomIndex = Math.floor(Math.random() * allLandTiles.length);
                const selectedTile = allLandTiles[randomIndex];
                gameState.naturalShelters.add(selectedTile);
                allLandTiles.splice(randomIndex, 1); // Remove so we don't duplicate
            }
        }
        
        // Initialize berry bushes randomly (20-25% of land tiles)
        function initializeBerryBushes() {
            gameState.berryBushes.clear();
            const allLandTiles = [];
            
            // Create array of all land tiles only
            for (let row = 0; row < gameState.mapSize; row++) {
                for (let col = 0; col < gameState.mapSize; col++) {
                    const tileKey = getTileKey(row, col);
                    if (gameState.landTiles.has(tileKey)) {
                        allLandTiles.push(tileKey);
                    }
                }
            }
            
            // Calculate 20-25% of land tiles
            const berryPercentage = 0.2 + Math.random() * 0.05; // 0.2 to 0.25
            const numBushes = Math.floor(allLandTiles.length * berryPercentage);
            
            // Randomly select land tiles for berry bushes (all start as 'full')
            const bushCount = Math.min(numBushes, allLandTiles.length);
            for (let i = 0; i < bushCount && allLandTiles.length > 0; i++) {
                const randomIndex = Math.floor(Math.random() * allLandTiles.length);
                const selectedTile = allLandTiles[randomIndex];
                gameState.berryBushes.set(selectedTile, 'full');
                allLandTiles.splice(randomIndex, 1); // Remove so we don't duplicate
            }
        }
        
        // Generate island
        gameState.landTiles = generateIsland();
        
        // Ensure starting position is on land (never on border)
        function findValidStartPosition() {
            // Find nearest land tile from bottom-left (but not on border)
            for (let col = 1; col < gameState.mapSize - 1; col++) {
                for (let row = gameState.mapSize - 2; row >= 1; row--) {
                    const key = getTileKey(row, col);
                    if (gameState.landTiles.has(key)) {
                        return { row, col };
                    }
                }
            }
            
            // Fallback: find any land tile (not on border)
            for (const key of gameState.landTiles) {
                const [row, col] = key.split(',').map(Number);
                if (row > 0 && row < gameState.mapSize - 1 && 
                    col > 0 && col < gameState.mapSize - 1) {
                    return { row, col };
                }
            }
            
            return { row: 8, col: 8 }; // Ultimate fallback (center)
        }
        
        const startPos = findValidStartPosition();
        character.position = startPos;
        
        // Mark the starting position as visited
        gameState.visitedTiles.add(getTileKey(startPos.row, startPos.col));
        
        // Function to find valid starting position for player 2 (near player 1)
        function findValidStartPositionForPlayer2() {
            // Players start in the same tile
            return { row: character.position.row, col: character.position.col };
        }
        
        // Check if players are on the same tile
        function playersOnSameTile() {
            return character2.active && 
                   character.position.row === character2.position.row && 
                   character.position.col === character2.position.col;
        }
        
        // Tiles are now dynamically revealed based on player position
        
        // Initialize natural shelters on load
        initializeNaturalShelters();
        
        // Initialize berry bushes on load
        initializeBerryBushes();
        
        // Check if a tile is adjacent (including diagonals) or current
        function isAdjacentOrCurrent(row, col) {
            const exploringPlayer = gameState.exploringPlayer === 2 ? character2 : character;
            const rowDiff = Math.abs(row - exploringPlayer.position.row);
            const colDiff = Math.abs(col - exploringPlayer.position.col);
            const isAdjacent = rowDiff <= 1 && colDiff <= 1;
            
            // Also check if it's a land tile
            const tileKey = getTileKey(row, col);
            const isLand = gameState.landTiles.has(tileKey);
            
            return isAdjacent && isLand;
        }
        
        // Reveal tiles around the player (8 surrounding tiles)
        // Check if a tile is currently adjacent to any player (for dynamic fog of war)
        function isTileAdjacentToAnyPlayer(row, col) {
            // Check if adjacent to player 1
            const rowDiff1 = Math.abs(row - character.position.row);
            const colDiff1 = Math.abs(col - character.position.col);
            if (rowDiff1 <= 1 && colDiff1 <= 1) {
                return true;
            }
            
            // Check if adjacent to player 2 (if active)
            if (character2.active) {
                const rowDiff2 = Math.abs(row - character2.position.row);
                const colDiff2 = Math.abs(col - character2.position.col);
                if (rowDiff2 <= 1 && colDiff2 <= 1) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Check if a land tile touches water (making it a beach)
        function isBeachTile(row, col) {
            // Check all 8 surrounding tiles
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue; // Skip center
                    
                    const newRow = row + dr;
                    const newCol = col + dc;
                    
                    // Check if this neighbor is water (or out of bounds, which counts as water)
                    if (newRow < 0 || newRow >= gameState.mapSize || 
                        newCol < 0 || newCol >= gameState.mapSize) {
                        return true; // Edge of map = water
                    }
                    
                    const neighborKey = getTileKey(newRow, newCol);
                    if (!gameState.landTiles.has(neighborKey)) {
                        return true; // Neighbor is water
                    }
                }
            }
            
            return false; // No water neighbors = grass/interior
        }
        
        // Progress berry bush states when day passes
        function progressBerryBushes() {
            for (const [tileKey, state] of gameState.berryBushes) {
                // Only progress if this bush wasn't gathered from today
                if (!gameState.bushesGatheredToday.has(tileKey)) {
                    if (state === 'barren1') {
                        gameState.berryBushes.set(tileKey, 'barren2');
                    } else if (state === 'barren2') {
                        gameState.berryBushes.set(tileKey, 'picked');
                    } else if (state === 'picked') {
                        gameState.berryBushes.set(tileKey, 'full');
                    }
                    // 'full' stays 'full' unless gathered from
                }
            }
            // Clear the gathered list for the new day
            gameState.bushesGatheredToday.clear();
        }
        
        // Show day transition animation
        function showDayTransition(oldDay, newDay) {
            return new Promise((resolve) => {
                const overlay = document.getElementById('day-transition-overlay');
                const text = document.getElementById('day-transition-text');
                
                // Hide text and show overlay
                text.classList.remove('show');
                text.textContent = `Day ${oldDay}`;
                overlay.classList.add('active');
                
                // After blue fades in (1200ms), show text
                setTimeout(() => {
                    text.classList.add('show');
                }, 1200);
                
                // After showing old day (800ms), switch to new day
                setTimeout(() => {
                    text.textContent = `Day ${newDay}`;
                }, 2000);
                
                // After showing new day (800ms more), fade out text then overlay
                setTimeout(() => {
                    text.classList.remove('show');
                }, 2800);
                
                setTimeout(() => {
                    overlay.classList.remove('active');
                    setTimeout(resolve, 1200); // Wait for fade out to complete
                }, 3300);
            });
        }
        
        // Pass the day and check for death conditions
        async function passDayAndCheckDeath() {
            // Show day transition animation
            const oldDay = gameState.day;
            const newDay = gameState.day + 1;
            await showDayTransition(oldDay, newDay);
            
            // Process player 1
            const currentTileKey = getTileKey(character.position.row, character.position.col);
            let becameTired = false;
            
            // Check if on a shelter tile (built or natural)
            if (gameState.shelters.has(currentTileKey) || gameState.naturalShelters.has(currentTileKey)) {
                // Slept in shelter - not tired
                character.tired = false;
            } else {
                // No shelter - become tired (if not already tired)
                if (!character.tired) {
                    becameTired = true;
                }
                character.tired = true;
            }
            
            // Process player 2 if active
            if (character2.active) {
                const currentTileKey2 = getTileKey(character2.position.row, character2.position.col);
                
                if (gameState.shelters.has(currentTileKey2) || gameState.naturalShelters.has(currentTileKey2)) {
                    character2.tired = false;
                } else {
                    if (!character2.tired) {
                        becameTired = true;
                    }
                    character2.tired = true;
                }
            }
            
            gameState.day = newDay;
            progressBerryBushes();
            
            // Process FP/HP for player 1
            if (character.fp <= 0) {
                // Out of FP: try to auto-eat or lose HP
                if (gameState.food > 0) {
                    // Auto-eat: consume food to prevent HP loss
                    gameState.food = Math.max(0, gameState.food - 1);
                    // FP stays at 0
                } else {
                    // No food: lose HP
                    character.hp = Math.max(0, character.hp - 1);
                }
            } else {
                // Have FP: consume it
                character.fp = Math.max(0, character.fp - 1);
            }
            
            // Process FP/HP for player 2 if active
            if (character2.active) {
                if (character2.fp <= 0) {
                    if (gameState.food > 0) {
                        gameState.food = Math.max(0, gameState.food - 1);
                    } else {
                        character2.hp = Math.max(0, character2.hp - 1);
                    }
                } else {
                    character2.fp = Math.max(0, character2.fp - 1);
                }
            }
            
            // Check if either player is dead
            if (character.hp <= 0 || (character2.active && character2.hp <= 0)) {
                // Game over
                document.getElementById('game-over-overlay').classList.add('active');
            } else if (becameTired && !gameState.hasSeenTiredMessage) {
                // Show tired message only first time
                gameState.hasSeenTiredMessage = true;
                document.getElementById('tired-overlay').classList.add('active');
            }
            
            updateDisplay();
        }

        // Function to render the map
        function renderMap() {
            const mapGrid = document.getElementById('map-grid');
            mapGrid.innerHTML = ''; // Clear existing tiles
            
            for (let row = 0; row < gameState.mapSize; row++) {
                for (let col = 0; col < gameState.mapSize; col++) {
                    const tile = document.createElement('div');
                    tile.className = 'map-tile';
                    
                    const tileKey = getTileKey(row, col);
                    const isLand = gameState.landTiles.has(tileKey);
                    const isSeen = isTileAdjacentToAnyPlayer(row, col); // Dynamic visibility check
                    const isVisited = gameState.visitedTiles.has(tileKey);
                    const isBeach = isLand ? isBeachTile(row, col) : false;
                    
                    // Determine tile state for rendering
                    if (!isSeen && !isVisited) {
                        // FOGGED - very dark grey (not adjacent and not previously visited)
                        tile.classList.add('fogged');
                    } else if (isLand && !isVisited && isSeen) {
                        // SEEN LAND - dark color (beach or grass) - currently adjacent but not visited
                        if (isBeach) {
                            tile.classList.add('seen-beach');
                        } else {
                            tile.classList.add('seen-grass');
                        }
                    } else if (isLand && isVisited) {
                        // REVEALED LAND - light color (beach or grass)
                        if (isBeach) {
                            tile.classList.add('revealed-beach');
                        } else {
                            tile.classList.add('revealed-grass');
                        }
                        
                        // Show natural shelter if on revealed land
                        if (gameState.naturalShelters.has(tileKey)) {
                            const naturalShelterMarker = document.createElement('div');
                            naturalShelterMarker.className = 'natural-shelter-marker';
                            naturalShelterMarker.textContent = '‚ñ≤';
                            tile.appendChild(naturalShelterMarker);
                        }
                        
                        // Show built shelter if on revealed land
                        if (gameState.shelters.has(tileKey)) {
                            const shelterMarker = document.createElement('div');
                            shelterMarker.className = 'shelter-marker';
                            shelterMarker.textContent = '‚ñ≤';
                            tile.appendChild(shelterMarker);
                        }
                        
                        // Show berry bush only on revealed tiles
                        if (gameState.berryBushes.has(tileKey)) {
                            const berryMarker = document.createElement('div');
                            berryMarker.className = 'berry-marker';
                            const bushState = gameState.berryBushes.get(tileKey);
                            if (bushState === 'picked') {
                                berryMarker.classList.add('picked');
                            } else if (bushState === 'barren1' || bushState === 'barren2') {
                                berryMarker.classList.add('barren');
                            }
                            berryMarker.textContent = '‚óè';
                            tile.appendChild(berryMarker);
                        }
                    } else if (!isLand && isSeen) {
                        // SEEN WATER - blue
                        tile.classList.add('seen-water');
                    }
                    
                    // Outline player's current tile(s)
                    const isPlayer1Here = (row === character.position.row && col === character.position.col);
                    const isPlayer2Here = (character2.active && row === character2.position.row && col === character2.position.col);
                    
                    if (isPlayer1Here && isPlayer2Here) {
                        // Both players on same tile - split border colors
                        tile.style.borderTop = '3px solid #d95555';
                        tile.style.borderRight = '3px solid #29496b';
                        tile.style.borderBottom = '3px solid #d95555';
                        tile.style.borderLeft = '3px solid #29496b';
                    } else if (isPlayer1Here) {
                        // Only player 1
                        tile.style.outline = '3px solid #d95555';
                        tile.style.outlineOffset = '-3px';
                    } else if (isPlayer2Here) {
                        // Only player 2
                        tile.style.outline = '3px solid #29496b';
                        tile.style.outlineOffset = '-3px';
                    }
                    
                    // Add click handler if exploring
                    if (gameState.isExploring) {
                        const exploringPlayer = gameState.exploringPlayer === 2 ? character2 : character;
                        if (isAdjacentOrCurrent(row, col)) {
                            tile.style.cursor = 'pointer';
                            tile.addEventListener('click', () => handleTileClick(row, col));
                            
                            // Add hover class based on whether it's current or adjacent
                            if (row === exploringPlayer.position.row && col === exploringPlayer.position.col) {
                                tile.classList.add('clickable-current');
                            } else {
                                tile.classList.add('clickable-adjacent');
                            }
                        }
                    }
                    
                    mapGrid.appendChild(tile);
                }
            }
        }

        // Function to handle tile clicks during exploration
        function handleTileClick(row, col) {
            const targetKey = getTileKey(row, col);
            const exploringPlayer = gameState.exploringPlayer === 2 ? character2 : character;
            
            // Don't allow moving to water tiles
            if (!gameState.landTiles.has(targetKey)) {
                return; // Can't move to water
            }
            
            // Move player if not current position
            if (row !== exploringPlayer.position.row || col !== exploringPlayer.position.col) {
                exploringPlayer.position.row = row;
                exploringPlayer.position.col = col;
                
                // If players are linked, move both players together
                if (character2.active && gameState.playersLinked) {
                    character.position.row = row;
                    character.position.col = col;
                    character2.position.row = row;
                    character2.position.col = col;
                }
                
                // Mark tile as visited (revealed)
                gameState.visitedTiles.add(getTileKey(row, col));
            }
            
            // Decrement moves
            gameState.movesRemaining--;
            
            // Check if exploration is done
            if (gameState.movesRemaining <= 0) {
                endExploration();
            } else {
                updateDisplay();
            }
        }
        
        // End exploration and pass the day
        function endExploration() {
            gameState.isExploring = false;
            gameState.movesRemaining = 0;
            gameState.exploringPlayer = null;
            document.getElementById('map-panel').classList.remove('exploring');
            document.getElementById('moves-remaining').style.display = 'none';
            
            // Update display to show newly revealed tiles before day transition
            updateDisplay();
            
            // Small delay to ensure map renders before animation starts
            setTimeout(() => {
                endTurn();
            }, 50);
        }
        
        // Function to update the display based on the character model
        function updateDisplay() {
            const nameText1 = document.querySelector('#player-name .name-text');
            // Only update if it's not currently being edited
            if (nameText1) {
                nameText1.textContent = character.name;
            }
            
            document.getElementById('hp-display').textContent = `HP: ${character.hp}`;
            document.getElementById('fp-display').textContent = `FP: ${character.fp}`;
            document.getElementById('item1-display').textContent = `Item 1: ${character.inventory[0] || 'none'}`;
            document.getElementById('item2-display').textContent = `Item 2: ${character.inventory[1] || 'none'}`;
            document.getElementById('item3-display').textContent = `Item 3: ${character.inventory[2] || 'none'}`;
            document.getElementById('day-display').textContent = `Day ${gameState.day}`;
            document.getElementById('food-text').textContent = `Food: ${Math.min(99, Math.max(0, gameState.food))}`;
            
            // Update second character display if active
            if (character2.active) {
                const nameText2 = document.querySelector('#player-name-2 .name-text');
                // Only update if it's not currently being edited
                if (nameText2) {
                    nameText2.textContent = character2.name;
                }
                document.getElementById('hp-display-2').textContent = `HP: ${character2.hp}`;
                document.getElementById('fp-display-2').textContent = `FP: ${character2.fp}`;
                document.getElementById('item1-display-2').textContent = `Item 1: ${character2.inventory[0] || 'none'}`;
                document.getElementById('item2-display-2').textContent = `Item 2: ${character2.inventory[1] || 'none'}`;
                document.getElementById('item3-display-2').textContent = `Item 3: ${character2.inventory[2] || 'none'}`;
            }
            
            // Update tired indicators
            const tiredIndicator1 = document.getElementById('tired-indicator-1');
            if (character.tired) {
                tiredIndicator1.classList.add('show');
            } else {
                tiredIndicator1.classList.remove('show');
            }
            
            if (character2.active) {
                const tiredIndicator2 = document.getElementById('tired-indicator-2');
                if (character2.tired) {
                    tiredIndicator2.classList.add('show');
                } else {
                    tiredIndicator2.classList.remove('show');
                }
            }
            
            // Update eat button state
            const eatCircle = document.getElementById('eat-circle');
            if (character.fp >= 4 || gameState.food <= 0) {
                eatCircle.disabled = true;
            } else {
                eatCircle.disabled = false;
            }
            
            // Update moves remaining display
            if (gameState.isExploring) {
                document.getElementById('moves-remaining').textContent = `${gameState.movesRemaining} moves remaining`;
                document.getElementById('moves-remaining').style.display = 'block';
            } else {
                document.getElementById('moves-remaining').style.display = 'none';
            }
            
            // Update current player display
            const currentPlayerDisplay = document.getElementById('current-player-display');
            if (character2.active) {
                const currentPlayer = gameState.currentTurn === 1 ? character : character2;
                currentPlayerDisplay.textContent = `[${currentPlayer.name}]`;
                currentPlayerDisplay.style.display = 'block';
            } else {
                currentPlayerDisplay.style.display = 'none';
            }
            
            // Update AP indicators
            const ap1Indicator = document.getElementById('ap-indicator-1');
            const ap2Indicator = document.getElementById('ap-indicator-2');
            
            // Always show player 1's AP indicator
            ap1Indicator.style.display = 'block';
            if (character.ap > 0) {
                ap1Indicator.classList.remove('spent');
            } else {
                ap1Indicator.classList.add('spent');
            }
            
            if (character2.active) {
                // Show player 2's AP indicator in multiplayer
                ap2Indicator.style.display = 'block';
                
                // Update AP status for player 2
                if (character2.ap > 0) {
                    ap2Indicator.classList.remove('spent');
                } else {
                    ap2Indicator.classList.add('spent');
                }
                
                // Highlight active player's panel
                const panel1 = document.getElementById('character-panel-1');
                const panel2 = document.getElementById('character-panel-2');
                
                if (gameState.currentTurn === 1) {
                    panel1.classList.add('active-turn');
                    panel2.classList.remove('active-turn');
                } else {
                    panel1.classList.remove('active-turn');
                    panel2.classList.add('active-turn');
                }
            } else {
                // Hide player 2's AP indicator in single player
                ap2Indicator.style.display = 'none';
                document.getElementById('character-panel-1').classList.remove('active-turn');
            }
            
            // Check if there's already a shelter at current position (built or natural)
            const currentPlayer = character2.active && gameState.currentTurn === 2 ? character2 : character;
            const currentTileKey = getTileKey(currentPlayer.position.row, currentPlayer.position.col);
            const buildShelterButton = document.getElementById('build-shelter');
            const gatherFoodButton = document.getElementById('gather-food');
            const exploreButton = document.getElementById('explore');
            
            // Disable all action buttons during exploration
            if (gameState.isExploring) {
                buildShelterButton.disabled = true;
                gatherFoodButton.disabled = true;
                exploreButton.disabled = true;
            } else {
                // Normal button state logic when not exploring
                if (gameState.shelters.has(currentTileKey) || gameState.naturalShelters.has(currentTileKey)) {
                    buildShelterButton.disabled = true;
                } else {
                    buildShelterButton.disabled = false;
                }
                gatherFoodButton.disabled = false;
                exploreButton.disabled = false;
            }
            
            // Update link button
            if (character2.active) {
                updateLinkButton();
            }
            
            // Update map key player names
            document.getElementById('map-key-name-1').textContent = character.name;
            if (character2.active) {
                document.getElementById('map-key-name-2').textContent = character2.name;
            }
            
            renderMap();
        }

        // Function to end current player's turn
        function endTurn() {
            // Spend the current player's AP
            const currentPlayer = character2.active && gameState.currentTurn === 2 ? character2 : character;
            currentPlayer.ap = 0;
            
            if (!character2.active) {
                // Single player mode - just pass the day and reset AP
                character.ap = 1;
                passDayAndCheckDeath();
                return;
            }
            
            // Check if both players have spent their AP
            if (character.ap === 0 && character2.ap === 0) {
                // Both players have acted, pass the day and reset AP
                character.ap = 1;
                character2.ap = 1;
                gameState.currentTurn = 1;
                passDayAndCheckDeath();
            } else {
                // Find next player with AP
                if (gameState.currentTurn === 1 && character2.ap > 0) {
                    gameState.currentTurn = 2;
                } else if (gameState.currentTurn === 2 && character.ap > 0) {
                    gameState.currentTurn = 1;
                }
                updateDisplay();
            }
        }

        // Button click handlers
        document.getElementById('build-shelter').addEventListener('click', () => {
            if (!gameState.isExploring) {
                const currentPlayer = character2.active && gameState.currentTurn === 2 ? character2 : character;
                const currentTileKey = getTileKey(currentPlayer.position.row, currentPlayer.position.col);
                
                // Only build if there's no shelter already (built or natural)
                if (!gameState.shelters.has(currentTileKey) && !gameState.naturalShelters.has(currentTileKey)) {
                    gameState.shelters.add(currentTileKey);
                    
                    // Update display to show new shelter before day transition
                    updateDisplay();
                    
                    // Small delay to ensure map renders before animation starts
                    setTimeout(() => {
                        endTurn();
                    }, 50);
                }
            }
        });

        document.getElementById('gather-food').addEventListener('click', () => {
            if (!gameState.isExploring) {
                const currentPlayer = character2.active && gameState.currentTurn === 2 ? character2 : character;
                const currentTileKey = getTileKey(currentPlayer.position.row, currentPlayer.position.col);
                let foodFound = 0;
                let gatheredFromBush = false;
                
                // Check if on a berry bush
                if (gameState.berryBushes.has(currentTileKey)) {
                    const bushState = gameState.berryBushes.get(currentTileKey);
                    
                    if (bushState === 'full') {
                        // Full bush: 4-8 food, becomes picked
                        foodFound = Math.floor(Math.random() * 5) + 4;
                        gameState.berryBushes.set(currentTileKey, 'picked');
                        gameState.bushesGatheredToday.add(currentTileKey);
                        gatheredFromBush = true;
                    } else if (bushState === 'picked') {
                        // Picked bush: 2-4 food, becomes barren1
                        foodFound = Math.floor(Math.random() * 3) + 2;
                        gameState.berryBushes.set(currentTileKey, 'barren1');
                        gameState.bushesGatheredToday.add(currentTileKey);
                        gatheredFromBush = true;
                    }
                    // Barren bushes (barren1, barren2): ignore the bush, gather normally, let it regenerate
                }
                
                // If didn't gather from bush (no bush, or barren bush), use regular gathering
                if (!gatheredFromBush) {
                    foodFound = Math.floor(Math.random() * 3);
                }
                
                // Add to food storage (capped at 99)
                gameState.food = Math.min(99, gameState.food + foodFound);
                
                // Show modal
                document.getElementById('modal-message').textContent = `You've found ${foodFound} units of food!`;
                document.getElementById('modal-overlay').classList.add('active');
                
                // Update display to show new food count
                updateDisplay();
            }
        });

        document.getElementById('explore').addEventListener('click', () => {
            if (!gameState.isExploring) {
                const currentPlayer = character2.active && gameState.currentTurn === 2 ? character2 : character;
                gameState.isExploring = true;
                gameState.exploringPlayer = gameState.currentTurn; // Track which player is exploring
                // Tired players only get 1 move
                gameState.movesRemaining = currentPlayer.tired ? 1 : 2;
                document.getElementById('map-panel').classList.add('exploring');
                updateDisplay();
            }
        });

        // Function to reset the game
        function resetGame() {
            // Reset character
            character.hp = 4;
            character.fp = 4;
            character.inventory = [null, null, null];
            character.tired = false;
            character.ap = 1;
            
            // Reset second character
            character2.hp = 4;
            character2.fp = 4;
            character2.inventory = [null, null, null];
            character2.tired = false;
            character2.active = false;
            character2.ap = 1;
            
            // Hide second character panel and show add button
            document.getElementById('character-panel-2').classList.remove('show');
            document.getElementById('add-player-btn').classList.remove('hidden');
            document.getElementById('player2-key').style.display = 'none';
            document.getElementById('link-btn').classList.remove('show');
            
            // Reset players linked state
            gameState.playersLinked = true;
            updateLinkButton();
            
            // Reset game state
            gameState.day = 1;
            gameState.visitedTiles.clear();
            gameState.seenTiles.clear();
            gameState.shelters.clear();
            gameState.naturalShelters.clear();
            gameState.bushesGatheredToday.clear();
            gameState.isExploring = false;
            gameState.movesRemaining = 0;
            gameState.food = 0;
            gameState.hasSeenTiredMessage = false;
            gameState.currentTurn = 1;
            gameState.exploringPlayer = null;
            
            // Generate new random seed for new island shape
            islandSeed = Math.random() * 100000;
            
            // Regenerate island
            gameState.landTiles = generateIsland();
            
            // Find valid starting position
            function findValidStartPositionReset() {
                // Find nearest land tile from bottom-left (but not on border)
                for (let col = 1; col < gameState.mapSize - 1; col++) {
                    for (let row = gameState.mapSize - 2; row >= 1; row--) {
                        const key = getTileKey(row, col);
                        if (gameState.landTiles.has(key)) {
                            return { row, col };
                        }
                    }
                }
                
                // Fallback: find any land tile (not on border)
                for (const key of gameState.landTiles) {
                    const [row, col] = key.split(',').map(Number);
                    if (row > 0 && row < gameState.mapSize - 1 && 
                        col > 0 && col < gameState.mapSize - 1) {
                        return { row, col };
                    }
                }
                
                return { row: 8, col: 8 }; // Ultimate fallback (center)
            }
            
            const startPos = findValidStartPositionReset();
            character.position = startPos;
            character2.position = startPos; // Reset character 2 position
            gameState.visitedTiles.add(getTileKey(startPos.row, startPos.col));
            
            // Tiles are now dynamically revealed based on player position
            
            // Reinitialize natural shelters and berry bushes
            initializeNaturalShelters();
            initializeBerryBushes();
            
            // Clear exploration UI
            document.getElementById('map-panel').classList.remove('exploring');
            document.getElementById('moves-remaining').style.display = 'none';
            
            // Hide game over screen if showing
            document.getElementById('game-over-overlay').classList.remove('active');
            
            // Update display
            updateDisplay();
        }

        // Reset button handler
        document.getElementById('reset-button').addEventListener('click', () => {
            resetGame();
        });
        
        // Try again button handler
        document.getElementById('try-again').addEventListener('click', () => {
            resetGame();
        });
        
        // Tired Ok button handler
        document.getElementById('tired-ok').addEventListener('click', () => {
            document.getElementById('tired-overlay').classList.remove('active');
        });

        // Eat button handler
        document.getElementById('eat-circle').addEventListener('click', () => {
            if (gameState.food > 0 && character.fp < 4) {
                gameState.food--;
                character.fp = Math.min(4, character.fp + 1);
                updateDisplay();
            }
        });

        // Modal Ok button handler
        document.getElementById('modal-ok').addEventListener('click', () => {
            // Hide modal
            document.getElementById('modal-overlay').classList.remove('active');
            
            // Update display to show berry bush state changes before day transition
            updateDisplay();
            
            // Small delay to ensure map renders before animation starts
            setTimeout(() => {
                endTurn();
            }, 50);
        });
        
        // Add player button handler
        document.getElementById('add-player-btn').addEventListener('click', () => {
            character2.active = true;
            document.getElementById('character-panel-2').classList.add('show');
            document.getElementById('add-player-btn').classList.add('hidden');
            document.getElementById('player2-key').style.display = 'flex';
            document.getElementById('link-btn').classList.add('show');
            
            // Ensure character 2 starts on a valid land tile
            const startPos2 = findValidStartPositionForPlayer2();
            character2.position = startPos2;
            
            // Mark starting position as visited
            gameState.visitedTiles.add(getTileKey(startPos2.row, startPos2.col));
            
            // Attach click handler for second player name
            const nameText2 = document.querySelector('#player-name-2 .name-text');
            if (nameText2 && !nameText2.dataset.hasClickHandler) {
                nameText2.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent panel click
                    makeNameEditable('player-name-2', character2);
                });
                nameText2.dataset.hasClickHandler = 'true';
            }
            
            updateDisplay();
        });
        
        // Link button handler
        document.getElementById('link-btn').addEventListener('click', () => {
            // Only allow linking/unlinking when players are on same tile
            if (playersOnSameTile()) {
                gameState.playersLinked = !gameState.playersLinked;
                updateLinkButton();
            }
        });
        
        // Function to update link button appearance
        function updateLinkButton() {
            const linkBtn = document.getElementById('link-btn');
            linkBtn.textContent = 'üîó';
            
            // Remove inline opacity to let CSS classes handle it
            linkBtn.style.opacity = '';
            
            if (!playersOnSameTile()) {
                // Players not on same tile - can't link, show grayed out
                linkBtn.classList.add('unlinked');
                linkBtn.classList.add('disabled');
                linkBtn.style.cursor = 'not-allowed';
                linkBtn.title = 'Players must be on the same tile to link';
            } else if (gameState.playersLinked) {
                linkBtn.classList.remove('unlinked');
                linkBtn.classList.remove('disabled');
                linkBtn.style.cursor = 'pointer';
                linkBtn.title = 'Players linked (click to unlink)';
            } else {
                linkBtn.classList.add('unlinked');
                linkBtn.classList.remove('disabled');
                linkBtn.style.cursor = 'pointer';
                linkBtn.title = 'Players unlinked (click to link)';
            }
        }
        
        // Function to make name editable
        function makeNameEditable(elementId, characterObj) {
            const nameElement = document.getElementById(elementId);
            const nameTextSpan = nameElement.querySelector('.name-text');
            const currentName = characterObj.name;
            
            // Create input element
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentName;
            input.className = 'name-edit';
            input.style.flex = '0 1 auto';
            
            // Replace name span with input
            nameTextSpan.parentNode.replaceChild(input, nameTextSpan);
            input.focus();
            input.select();
            
            // Function to save and restore
            function saveAndRestore() {
                const newName = input.value.trim();
                if (newName) {
                    characterObj.name = newName;
                }
                
                // Create new name span
                const nameSpan = document.createElement('span');
                nameSpan.className = 'name-text';
                nameSpan.textContent = characterObj.name;
                
                // Replace input with name span
                input.parentNode.replaceChild(nameSpan, input);
                
                // Re-attach click handler
                nameSpan.addEventListener('click', (e) => {
                    e.stopPropagation();
                    makeNameEditable(elementId, characterObj);
                });
                
                // Update display to refresh map key names
                updateDisplay();
            }
            
            // Save on Enter
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveAndRestore();
                }
            });
            
            // Save on blur (clicking away)
            input.addEventListener('blur', saveAndRestore);
        }
        
        // Add click handler to first player name text
        document.querySelector('#player-name .name-text').addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent panel click
            makeNameEditable('player-name', character);
        });
        
        // Add click handlers to character panels for switching turns
        document.getElementById('character-panel-1').addEventListener('click', () => {
            if (character2.active && character.ap > 0 && !gameState.isExploring) {
                gameState.currentTurn = 1;
                updateDisplay();
            }
        });
        
        document.getElementById('character-panel-2').addEventListener('click', () => {
            if (character2.active && character2.ap > 0 && !gameState.isExploring) {
                gameState.currentTurn = 2;
                updateDisplay();
            }
        });

        // Initialize display
        updateDisplay();
        updateLinkButton();
    </script>
</body>
</html>


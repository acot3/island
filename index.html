<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Island Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            min-height: 100vh;
            margin: 0;
            background-image: url('bg.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed;
            position: relative;
        }
        
        .character-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-width: 200px;
            text-align: left;
        }
        
        .character-panel h2 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }
        
        .character-panel p {
            margin: 8px 0;
            color: #555;
        }
        
        .status-panel {
            position: absolute;
            top: 20px;
            left: 280px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-size: 32px;
            display: none;
        }
        
        .status-panel.show {
            display: block;
        }
        
        .food-card {
            position: absolute;
            top: 230px;
            left: 20px;
            background: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-width: 200px;
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: center;
            gap: 10px;
        }
        
        .food-text {
            color: #555;
            font-weight: bold;
        }
        
        .eat-circle {
            padding: 5px 10px;
            background-color: #FF9800;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            width: fit-content;
        }
        
        .eat-circle:hover:not(:disabled) {
            background-color: #F57C00;
        }
        
        .eat-circle:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .day-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-size: 20px;
            font-weight: bold;
            color: #333;
        }
        
        .map-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: box-shadow 0.3s;
        }
        
        .map-panel.exploring {
            box-shadow: 0 0 0 4px gold;
        }
        
        .moves-remaining {
            position: absolute;
            top: 550px;
            right: 275px;
            transform: translateX(50%);
            text-align: center;
            font-weight: bold;
            color: #333;
            background: white;
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .map-key {
            position: absolute;
            top: 550px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-size: 14px;
        }
        
        .map-key-title {
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
        }
        
        .map-key-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            color: #555;
        }
        
        .map-key-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 8px;
            font-weight: bold;
            font-size: 12px;
        }
        
        .map-key-icon.player {
            background-color: white;
            outline: 3px solid #d95555;
            outline-offset: -3px;
        }
        
        .map-key-icon.berry {
            background-color: #a8326d;
            color: white;
        }
        
        .map-key-icon.shelter {
            background-color: #8B4513;
            color: white;
        }
        
        .map-key-icon.natural-shelter {
            background-color: #FFD700;
            color: white;
        }
        
        .map-grid {
            display: grid;
            grid-template-columns: repeat(16, 30px);
            grid-template-rows: repeat(16, 30px);
            gap: 0px;
        }
        
        .map-tile {
            background-color: #424242;
            border: 1px solid #999;
            position: relative;
        }
        
        .map-tile.fogged {
            background-color: #424242;
        }
        
        .map-tile.seen-beach {
            background-color: #8f816f;
        }
        
        .map-tile.revealed-beach {
            background-color: #e6d1b5;
        }
        
        .map-tile.seen-grass {
            background-color: #244f27;
        }
        
        .map-tile.revealed-grass {
            background-color: #4ea354;
        }
        
        .map-tile.seen-water {
            background-color: #4a90e2;
        }
        
        .map-tile.clickable-adjacent:hover {
            background-color: #87CEEB;
        }
        
        .map-tile.clickable-current:hover {
            background-color: #4682B4;
        }
        
        .player-marker {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 50%;
            height: 50%;
            background-color: #d95555;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 7px;
        }
        
        .shelter-marker {
            position: absolute;
            top: 0;
            left: 0;
            width: 50%;
            height: 50%;
            background-color: #8B4513;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 7px;
        }
        
        .natural-shelter-marker {
            position: absolute;
            top: 0;
            left: 0;
            width: 50%;
            height: 50%;
            background-color: #FFD700;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 7px;
        }
        
        .berry-marker {
            position: absolute;
            top: 0;
            right: 0;
            width: 50%;
            height: 50%;
            background-color: #a8326d;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 7px;
        }
        
        .berry-marker.picked {
            background-color: #d4a5ba;
        }
        
        .berry-marker.barren {
            background-color: #888;
        }
        
        .game-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        .container {
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        h1 {
            margin-bottom: 30px;
            color: #333;
        }
        
        button {
            display: block;
            width: 200px;
            padding: 15px;
            margin: 10px auto;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .reset-button {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 10px 20px;
            font-size: 14px;
            background-color: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: auto;
        }
        
        .reset-button:hover {
            background-color: #da190b;
        }
        
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .modal-overlay.active {
            display: flex;
        }
        
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            text-align: center;
            max-width: 400px;
        }
        
        .modal-content p {
            margin: 0 0 20px 0;
            font-size: 18px;
            color: #333;
        }
        
        .modal-content button {
            width: 100px;
            padding: 10px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .modal-content button:hover {
            background-color: #45a049;
        }
        
        .game-over-content {
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            text-align: center;
            max-width: 400px;
        }
        
        .game-over-content h1 {
            margin: 0 0 20px 0;
            font-size: 48px;
            color: #d32f2f;
        }
        
        .game-over-content p {
            margin: 0 0 30px 0;
            font-size: 24px;
            color: #333;
        }
        
        .game-over-content button {
            width: 150px;
            padding: 12px;
            font-size: 18px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .game-over-content button:hover {
            background-color: #45a049;
        }
        
        .tired-content {
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            text-align: center;
            max-width: 500px;
        }
        
        .tired-content h2 {
            margin: 0 0 20px 0;
            font-size: 32px;
            color: #333;
        }
        
        .tired-content p {
            margin: 10px 0;
            font-size: 18px;
            color: #555;
        }
        
        .tired-content button {
            margin-top: 20px;
            width: 100px;
            padding: 10px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .tired-content button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div class="character-panel">
        <h2 id="player-name">Player name: Albert</h2>
        <p id="hp-display">HP: 4</p>
        <p id="fp-display">FP: 4</p>
        <p id="item1-display">Item 1: none</p>
        <p id="item2-display">Item 2: none</p>
        <p id="item3-display">Item 3: none</p>
    </div>
    
    <div class="status-panel" id="status-panel">ü•±</div>
    
    <div class="food-card">
        <span class="food-text" id="food-text">Food: 0</span>
        <button class="eat-circle" id="eat-circle">Eat</button>
    </div>
    
    <div class="day-display" id="day-display">Day 1</div>
    
    <div class="map-panel" id="map-panel">
        <div class="map-grid" id="map-grid"></div>
    </div>
    <div class="moves-remaining" id="moves-remaining" style="display: none;"></div>
    
    <div class="map-key">
        <div class="map-key-title">Key:</div>
        <div class="map-key-item">
            <div class="map-key-icon player"></div>
            <span>Player</span>
        </div>
        <div class="map-key-item">
            <div class="map-key-icon berry">‚óè</div>
            <span>Berry Bush</span>
        </div>
        <div class="map-key-item">
            <div class="map-key-icon natural-shelter">‚ñ≤</div>
            <span>Natural Shelter</span>
        </div>
        <div class="map-key-item">
            <div class="map-key-icon shelter">‚ñ≤</div>
            <span>Built Shelter</span>
        </div>
    </div>
    
    <button class="reset-button" id="reset-button">Reset Game</button>
    
    <div class="game-container">
        <div class="container">
            <h1>Today's activity?</h1>
            <button id="build-shelter">1. Build Shelter</button>
            <button id="gather-food">2. Gather Food</button>
            <button id="explore">3. Explore</button>
        </div>
    </div>
    
    <div class="modal-overlay" id="modal-overlay">
        <div class="modal-content">
            <p id="modal-message"></p>
            <button id="modal-ok">Ok</button>
        </div>
    </div>
    
    <div class="modal-overlay" id="game-over-overlay">
        <div class="game-over-content">
            <h1>Game Over</h1>
            <p>You've died!</p>
            <button id="try-again">Try Again</button>
        </div>
    </div>
    
    <div class="modal-overlay" id="tired-overlay">
        <div class="tired-content">
            <h2>Sleeping on the ground, you get very little rest.</h2>
            <p>Status gained: Tired</p>
            <p>Movement penalty: -1</p>
            <button id="tired-ok">Ok</button>
            <p>(Sleep in a shelter to avoid this.)</p>
        </div>
    </div>

    <script>
        // Character model
        const character = {
            name: "Albert",
            hp: 4,
            fp: 4,
            inventory: [null, null, null],
            position: { row: 15, col: 0 }, // Bottom left (0-indexed, row 15 = bottom)
            tired: false
        };

        // Game state
        const gameState = {
            day: 1,
            mapSize: 16, // 16x16 grid
            visitedTiles: new Set(), // Track which tiles have been visited (revealed)
            seenTiles: new Set(), // Track which tiles the player has seen (but maybe not visited)
            landTiles: new Set(), // Track which tiles are land vs water
            shelters: new Set(), // Track which tiles have built shelters
            naturalShelters: new Set(), // Track which tiles have natural shelters
            berryBushes: new Map(), // Track berry bushes and their states: 'full', 'picked', 'barren1', 'barren2'
            bushesGatheredToday: new Set(), // Track which bushes were gathered from today
            isExploring: false,
            movesRemaining: 0,
            food: 0, // Food storage (not part of character)
            hasSeenTiredMessage: false // Track if player has seen tired message this game
        };
        
        // Helper function to create a tile key
        function getTileKey(row, col) {
            return `${row},${col}`;
        }
        
        // Random seed for island generation
        let islandSeed = Math.random() * 100000;
        
        // Simple noise function
        function simpleNoise(x, y) {
            const n = Math.sin(x * 12.9898 + y * 78.233 + islandSeed) * 43758.5453;
            return (n - Math.floor(n)) * 2 - 1;
        }
        
        // Multi-octave noise for more natural terrain
        function multiOctaveNoise(x, y) {
            let value = 0;
            let amplitude = 1;
            let frequency = 1;
            
            for (let i = 0; i < 3; i++) {
                value += simpleNoise(x * frequency, y * frequency) * amplitude;
                amplitude *= 0.5;
                frequency *= 2;
            }
            
            return value / 1.75; // Normalize
        }
        
        // Flood fill to find connected land tiles
        function floodFill(startKey, landTiles) {
            const visited = new Set();
            const queue = [startKey];
            visited.add(startKey);
            
            while (queue.length > 0) {
                const current = queue.shift();
                const [row, col] = current.split(',').map(Number);
                
                // Check all 4 cardinal directions (not diagonals for island connection)
                const neighbors = [
                    [row - 1, col],
                    [row + 1, col],
                    [row, col - 1],
                    [row, col + 1]
                ];
                
                for (const [nRow, nCol] of neighbors) {
                    if (nRow >= 0 && nRow < gameState.mapSize && nCol >= 0 && nCol < gameState.mapSize) {
                        const neighborKey = getTileKey(nRow, nCol);
                        if (landTiles.has(neighborKey) && !visited.has(neighborKey)) {
                            visited.add(neighborKey);
                            queue.push(neighborKey);
                        }
                    }
                }
            }
            
            return visited;
        }
        
        // Find the largest connected landmass
        function findLargestIsland(landTiles) {
            const allLand = new Set(landTiles);
            let largestIsland = new Set();
            
            while (allLand.size > 0) {
                const startKey = allLand.values().next().value;
                const island = floodFill(startKey, landTiles);
                
                if (island.size > largestIsland.size) {
                    largestIsland = island;
                }
                
                // Remove this island from consideration
                for (const tile of island) {
                    allLand.delete(tile);
                }
            }
            
            return largestIsland;
        }
        
        // Fill interior water holes (lakes) to make solid island
        function fillInteriorWater(landTiles) {
            const waterTiles = new Set();
            
            // Find all water tiles
            for (let row = 0; row < gameState.mapSize; row++) {
                for (let col = 0; col < gameState.mapSize; col++) {
                    const key = getTileKey(row, col);
                    if (!landTiles.has(key)) {
                        waterTiles.add(key);
                    }
                }
            }
            
            // Find water connected to edges (ocean)
            const oceanTiles = new Set();
            const edgeWaterTiles = [];
            
            // Collect water tiles on edges
            for (let row = 0; row < gameState.mapSize; row++) {
                for (let col = 0; col < gameState.mapSize; col++) {
                    if (row === 0 || row === gameState.mapSize - 1 || 
                        col === 0 || col === gameState.mapSize - 1) {
                        const key = getTileKey(row, col);
                        if (waterTiles.has(key)) {
                            edgeWaterTiles.push(key);
                        }
                    }
                }
            }
            
            // Flood fill from edge water to find all ocean tiles
            for (const startKey of edgeWaterTiles) {
                if (!oceanTiles.has(startKey)) {
                    const connected = floodFill(startKey, waterTiles);
                    for (const tile of connected) {
                        oceanTiles.add(tile);
                    }
                }
            }
            
            // Any water not connected to ocean is interior - convert to land
            const filledLand = new Set(landTiles);
            for (const waterTile of waterTiles) {
                if (!oceanTiles.has(waterTile)) {
                    filledLand.add(waterTile);
                }
            }
            
            return filledLand;
        }
        
        // Generate island shape using noise
        function generateIsland() {
            const totalTiles = gameState.mapSize * gameState.mapSize;
            const targetLandTiles = Math.floor(totalTiles * 0.8); // 80% land
            
            let attempts = 0;
            const maxAttempts = 10;
            
            while (attempts < maxAttempts) {
                const landTiles = new Set();
                
                // Parameters - scale varies with map size, add randomness
                const noiseScale = 0.15 + Math.random() * 0.1; // 0.15-0.25 (lower for bigger features)
                const threshold = -0.5 - Math.random() * 0.2; // -0.5 to -0.7 (more land)
                const falloffStrength = 0.3 + Math.random() * 0.2; // 0.3-0.5 (varied edge shapes)
                
                for (let row = 0; row < gameState.mapSize; row++) {
                    for (let col = 0; col < gameState.mapSize; col++) {
                        // Skip border tiles - they must always be water
                        if (row === 0 || row === gameState.mapSize - 1 || 
                            col === 0 || col === gameState.mapSize - 1) {
                            continue; // Border is always water
                        }
                        
                        // Get noise value (-1 to 1)
                        const noiseValue = multiOctaveNoise(col * noiseScale, row * noiseScale);
                        
                        // Distance from center (creates circular falloff)
                        const centerX = gameState.mapSize / 2;
                        const centerY = gameState.mapSize / 2;
                        const dx = col - centerX;
                        const dy = row - centerY;
                        const distanceFromCenter = Math.sqrt(dx * dx + dy * dy);
                        const normalizedDistance = distanceFromCenter / (gameState.mapSize / 2);
                        
                        // Combine noise with radial gradient
                        const heightValue = noiseValue - (normalizedDistance * falloffStrength);
                        
                        // If above threshold, it's land
                        if (heightValue > threshold) {
                            landTiles.add(getTileKey(row, col));
                        }
                    }
                }
                
                // Keep only the largest connected island
                const largestIsland = findLargestIsland(landTiles);
                
                // Fill any interior water pockets/holes
                const solidIsland = fillInteriorWater(largestIsland);
                
                // Check if we have enough land (at least 65% of target - more lenient)
                if (solidIsland.size >= targetLandTiles * 0.65) {
                    return solidIsland;
                }
                
                attempts++;
            }
            
            // Fallback: create a simple circular island if generation failed
            const fallbackIsland = new Set();
            const center = gameState.mapSize / 2;
            const radius = gameState.mapSize * 0.4; // Smaller to avoid edges
            
            for (let row = 0; row < gameState.mapSize; row++) {
                for (let col = 0; col < gameState.mapSize; col++) {
                    // Skip borders
                    if (row === 0 || row === gameState.mapSize - 1 || 
                        col === 0 || col === gameState.mapSize - 1) {
                        continue;
                    }
                    
                    const dx = col - center;
                    const dy = row - center;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < radius) {
                        fallbackIsland.add(getTileKey(row, col));
                    }
                }
            }
            
            // Fill any interior water holes in fallback too
            return fillInteriorWater(fallbackIsland);
        }
        
        // Initialize natural shelters randomly (20-25% of land tiles)
        function initializeNaturalShelters() {
            gameState.naturalShelters.clear();
            const allLandTiles = [];
            
            // Create array of all land tiles only
            for (let row = 0; row < gameState.mapSize; row++) {
                for (let col = 0; col < gameState.mapSize; col++) {
                    const tileKey = getTileKey(row, col);
                    if (gameState.landTiles.has(tileKey)) {
                        allLandTiles.push(tileKey);
                    }
                }
            }
            
            // Calculate 20-25% of land tiles
            const shelterPercentage = 0.2 + Math.random() * 0.05; // 0.2 to 0.25
            const numShelters = Math.floor(allLandTiles.length * shelterPercentage);
            
            // Randomly select land tiles for natural shelters
            const shelterCount = Math.min(numShelters, allLandTiles.length);
            for (let i = 0; i < shelterCount && allLandTiles.length > 0; i++) {
                const randomIndex = Math.floor(Math.random() * allLandTiles.length);
                const selectedTile = allLandTiles[randomIndex];
                gameState.naturalShelters.add(selectedTile);
                allLandTiles.splice(randomIndex, 1); // Remove so we don't duplicate
            }
        }
        
        // Initialize berry bushes randomly (20-25% of land tiles)
        function initializeBerryBushes() {
            gameState.berryBushes.clear();
            const allLandTiles = [];
            
            // Create array of all land tiles only
            for (let row = 0; row < gameState.mapSize; row++) {
                for (let col = 0; col < gameState.mapSize; col++) {
                    const tileKey = getTileKey(row, col);
                    if (gameState.landTiles.has(tileKey)) {
                        allLandTiles.push(tileKey);
                    }
                }
            }
            
            // Calculate 20-25% of land tiles
            const berryPercentage = 0.2 + Math.random() * 0.05; // 0.2 to 0.25
            const numBushes = Math.floor(allLandTiles.length * berryPercentage);
            
            // Randomly select land tiles for berry bushes (all start as 'full')
            const bushCount = Math.min(numBushes, allLandTiles.length);
            for (let i = 0; i < bushCount && allLandTiles.length > 0; i++) {
                const randomIndex = Math.floor(Math.random() * allLandTiles.length);
                const selectedTile = allLandTiles[randomIndex];
                gameState.berryBushes.set(selectedTile, 'full');
                allLandTiles.splice(randomIndex, 1); // Remove so we don't duplicate
            }
        }
        
        // Generate island
        gameState.landTiles = generateIsland();
        
        // Ensure starting position is on land (never on border)
        function findValidStartPosition() {
            // Find nearest land tile from bottom-left (but not on border)
            for (let col = 1; col < gameState.mapSize - 1; col++) {
                for (let row = gameState.mapSize - 2; row >= 1; row--) {
                    const key = getTileKey(row, col);
                    if (gameState.landTiles.has(key)) {
                        return { row, col };
                    }
                }
            }
            
            // Fallback: find any land tile (not on border)
            for (const key of gameState.landTiles) {
                const [row, col] = key.split(',').map(Number);
                if (row > 0 && row < gameState.mapSize - 1 && 
                    col > 0 && col < gameState.mapSize - 1) {
                    return { row, col };
                }
            }
            
            return { row: 8, col: 8 }; // Ultimate fallback (center)
        }
        
        const startPos = findValidStartPosition();
        character.position = startPos;
        
        // Mark the starting position as visited
        gameState.visitedTiles.add(getTileKey(startPos.row, startPos.col));
        
        // Reveal surrounding tiles at start
        revealSurroundingTiles(startPos.row, startPos.col);
        
        // Initialize natural shelters on load
        initializeNaturalShelters();
        
        // Initialize berry bushes on load
        initializeBerryBushes();
        
        // Check if a tile is adjacent (including diagonals) or current
        function isAdjacentOrCurrent(row, col) {
            const rowDiff = Math.abs(row - character.position.row);
            const colDiff = Math.abs(col - character.position.col);
            const isAdjacent = rowDiff <= 1 && colDiff <= 1;
            
            // Also check if it's a land tile
            const tileKey = getTileKey(row, col);
            const isLand = gameState.landTiles.has(tileKey);
            
            return isAdjacent && isLand;
        }
        
        // Reveal tiles around the player (8 surrounding tiles)
        function revealSurroundingTiles(row, col) {
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    
                    if (newRow >= 0 && newRow < gameState.mapSize && 
                        newCol >= 0 && newCol < gameState.mapSize) {
                        gameState.seenTiles.add(getTileKey(newRow, newCol));
                    }
                }
            }
        }
        
        // Check if a land tile touches water (making it a beach)
        function isBeachTile(row, col) {
            // Check all 8 surrounding tiles
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue; // Skip center
                    
                    const newRow = row + dr;
                    const newCol = col + dc;
                    
                    // Check if this neighbor is water (or out of bounds, which counts as water)
                    if (newRow < 0 || newRow >= gameState.mapSize || 
                        newCol < 0 || newCol >= gameState.mapSize) {
                        return true; // Edge of map = water
                    }
                    
                    const neighborKey = getTileKey(newRow, newCol);
                    if (!gameState.landTiles.has(neighborKey)) {
                        return true; // Neighbor is water
                    }
                }
            }
            
            return false; // No water neighbors = grass/interior
        }
        
        // Progress berry bush states when day passes
        function progressBerryBushes() {
            for (const [tileKey, state] of gameState.berryBushes) {
                // Only progress if this bush wasn't gathered from today
                if (!gameState.bushesGatheredToday.has(tileKey)) {
                    if (state === 'barren1') {
                        gameState.berryBushes.set(tileKey, 'barren2');
                    } else if (state === 'barren2') {
                        gameState.berryBushes.set(tileKey, 'picked');
                    } else if (state === 'picked') {
                        gameState.berryBushes.set(tileKey, 'full');
                    }
                    // 'full' stays 'full' unless gathered from
                }
            }
            // Clear the gathered list for the new day
            gameState.bushesGatheredToday.clear();
        }
        
        // Pass the day and check for death conditions
        function passDayAndCheckDeath() {
            const currentTileKey = getTileKey(character.position.row, character.position.col);
            let becameTired = false;
            
            // Check if on a shelter tile (built or natural)
            if (gameState.shelters.has(currentTileKey) || gameState.naturalShelters.has(currentTileKey)) {
                // Slept in shelter - not tired
                character.tired = false;
            } else {
                // No shelter - become tired (if not already tired)
                if (!character.tired) {
                    becameTired = true;
                }
                character.tired = true;
            }
            
            gameState.day++;
            progressBerryBushes();
            
            // Check FP first
            if (character.fp <= 0) {
                // Out of FP: try to auto-eat or lose HP
                if (gameState.food > 0) {
                    // Auto-eat: consume food to prevent HP loss
                    gameState.food = Math.max(0, gameState.food - 1);
                    // FP stays at 0
                } else {
                    // No food: lose HP
                    character.hp = Math.max(0, character.hp - 1);
                }
            } else {
                // Have FP: consume it
                character.fp = Math.max(0, character.fp - 1);
            }
            
            // Check if dead
            if (character.hp <= 0) {
                // Game over
                document.getElementById('game-over-overlay').classList.add('active');
            } else if (becameTired && !gameState.hasSeenTiredMessage) {
                // Show tired message only first time
                gameState.hasSeenTiredMessage = true;
                document.getElementById('tired-overlay').classList.add('active');
            }
            
            updateDisplay();
        }

        // Function to render the map
        function renderMap() {
            const mapGrid = document.getElementById('map-grid');
            mapGrid.innerHTML = ''; // Clear existing tiles
            
            for (let row = 0; row < gameState.mapSize; row++) {
                for (let col = 0; col < gameState.mapSize; col++) {
                    const tile = document.createElement('div');
                    tile.className = 'map-tile';
                    
                    const tileKey = getTileKey(row, col);
                    const isLand = gameState.landTiles.has(tileKey);
                    const isSeen = gameState.seenTiles.has(tileKey);
                    const isVisited = gameState.visitedTiles.has(tileKey);
                    const isBeach = isLand ? isBeachTile(row, col) : false;
                    
                    // Determine tile state for rendering
                    if (!isSeen) {
                        // FOGGED - very dark grey
                        tile.classList.add('fogged');
                    } else if (isLand && !isVisited) {
                        // SEEN LAND - dark color (beach or grass)
                        if (isBeach) {
                            tile.classList.add('seen-beach');
                        } else {
                            tile.classList.add('seen-grass');
                        }
                    } else if (isLand && isVisited) {
                        // REVEALED LAND - light color (beach or grass)
                        if (isBeach) {
                            tile.classList.add('revealed-beach');
                        } else {
                            tile.classList.add('revealed-grass');
                        }
                        
                        // Show natural shelter if on revealed land
                        if (gameState.naturalShelters.has(tileKey)) {
                            const naturalShelterMarker = document.createElement('div');
                            naturalShelterMarker.className = 'natural-shelter-marker';
                            naturalShelterMarker.textContent = '‚ñ≤';
                            tile.appendChild(naturalShelterMarker);
                        }
                        
                        // Show built shelter if on revealed land
                        if (gameState.shelters.has(tileKey)) {
                            const shelterMarker = document.createElement('div');
                            shelterMarker.className = 'shelter-marker';
                            shelterMarker.textContent = '‚ñ≤';
                            tile.appendChild(shelterMarker);
                        }
                        
                        // Show berry bush only on revealed tiles
                        if (gameState.berryBushes.has(tileKey)) {
                            const berryMarker = document.createElement('div');
                            berryMarker.className = 'berry-marker';
                            const bushState = gameState.berryBushes.get(tileKey);
                            if (bushState === 'picked') {
                                berryMarker.classList.add('picked');
                            } else if (bushState === 'barren1' || bushState === 'barren2') {
                                berryMarker.classList.add('barren');
                            }
                            berryMarker.textContent = '‚óè';
                            tile.appendChild(berryMarker);
                        }
                    } else if (!isLand && isSeen) {
                        // SEEN WATER - blue
                        tile.classList.add('seen-water');
                    }
                    
                        // Outline player's current tile
                    if (row === character.position.row && col === character.position.col) {
                        tile.style.outline = '3px solid #d95555';
                        tile.style.outlineOffset = '-3px';
                    }
                    
                    // Add click handler if exploring
                    if (gameState.isExploring) {
                        if (isAdjacentOrCurrent(row, col)) {
                            tile.style.cursor = 'pointer';
                            tile.addEventListener('click', () => handleTileClick(row, col));
                            
                            // Add hover class based on whether it's current or adjacent
                            if (row === character.position.row && col === character.position.col) {
                                tile.classList.add('clickable-current');
                            } else {
                                tile.classList.add('clickable-adjacent');
                            }
                        }
                    }
                    
                    mapGrid.appendChild(tile);
                }
            }
        }

        // Function to handle tile clicks during exploration
        function handleTileClick(row, col) {
            const targetKey = getTileKey(row, col);
            
            // Don't allow moving to water tiles
            if (!gameState.landTiles.has(targetKey)) {
                return; // Can't move to water
            }
            
            // Move player if not current position
            if (row !== character.position.row || col !== character.position.col) {
                character.position.row = row;
                character.position.col = col;
                // Mark tile as visited (revealed)
                gameState.visitedTiles.add(getTileKey(row, col));
                // Reveal surrounding 8 tiles
                revealSurroundingTiles(row, col);
            }
            
            // Decrement moves
            gameState.movesRemaining--;
            
            // Check if exploration is done
            if (gameState.movesRemaining <= 0) {
                endExploration();
            } else {
                updateDisplay();
            }
        }
        
        // End exploration and pass the day
        function endExploration() {
            gameState.isExploring = false;
            gameState.movesRemaining = 0;
            document.getElementById('map-panel').classList.remove('exploring');
            document.getElementById('moves-remaining').style.display = 'none';
            
            passDayAndCheckDeath();
        }
        
        // Function to update the display based on the character model
        function updateDisplay() {
            document.getElementById('player-name').textContent = `Player name: ${character.name}`;
            document.getElementById('hp-display').textContent = `HP: ${character.hp}`;
            document.getElementById('fp-display').textContent = `FP: ${character.fp}`;
            document.getElementById('item1-display').textContent = `Item 1: ${character.inventory[0] || 'none'}`;
            document.getElementById('item2-display').textContent = `Item 2: ${character.inventory[1] || 'none'}`;
            document.getElementById('item3-display').textContent = `Item 3: ${character.inventory[2] || 'none'}`;
            document.getElementById('day-display').textContent = `Day ${gameState.day}`;
            document.getElementById('food-text').textContent = `Food: ${Math.min(99, Math.max(0, gameState.food))}`;
            
            // Update status panel visibility
            const statusPanel = document.getElementById('status-panel');
            if (character.tired) {
                statusPanel.classList.add('show');
            } else {
                statusPanel.classList.remove('show');
            }
            
            // Update eat button state
            const eatCircle = document.getElementById('eat-circle');
            if (character.fp >= 4 || gameState.food <= 0) {
                eatCircle.disabled = true;
            } else {
                eatCircle.disabled = false;
            }
            
            // Update moves remaining display
            if (gameState.isExploring) {
                document.getElementById('moves-remaining').textContent = `${gameState.movesRemaining} moves remaining`;
                document.getElementById('moves-remaining').style.display = 'block';
            } else {
                document.getElementById('moves-remaining').style.display = 'none';
            }
            
            // Check if there's already a shelter at current position (built or natural)
            const currentTileKey = getTileKey(character.position.row, character.position.col);
            const buildShelterButton = document.getElementById('build-shelter');
            if (gameState.shelters.has(currentTileKey) || gameState.naturalShelters.has(currentTileKey)) {
                buildShelterButton.disabled = true;
            } else {
                buildShelterButton.disabled = false;
            }
            
            renderMap();
        }

        // Button click handlers
        document.getElementById('build-shelter').addEventListener('click', () => {
            if (!gameState.isExploring) {
                const currentTileKey = getTileKey(character.position.row, character.position.col);
                
                // Only build if there's no shelter already (built or natural)
                if (!gameState.shelters.has(currentTileKey) && !gameState.naturalShelters.has(currentTileKey)) {
                    gameState.shelters.add(currentTileKey);
                    passDayAndCheckDeath();
                }
            }
        });

        document.getElementById('gather-food').addEventListener('click', () => {
            if (!gameState.isExploring) {
                const currentTileKey = getTileKey(character.position.row, character.position.col);
                let foodFound = 0;
                let gatheredFromBush = false;
                
                // Check if on a berry bush
                if (gameState.berryBushes.has(currentTileKey)) {
                    const bushState = gameState.berryBushes.get(currentTileKey);
                    
                    if (bushState === 'full') {
                        // Full bush: 4-8 food, becomes picked
                        foodFound = Math.floor(Math.random() * 5) + 4;
                        gameState.berryBushes.set(currentTileKey, 'picked');
                        gameState.bushesGatheredToday.add(currentTileKey);
                        gatheredFromBush = true;
                    } else if (bushState === 'picked') {
                        // Picked bush: 2-4 food, becomes barren1
                        foodFound = Math.floor(Math.random() * 3) + 2;
                        gameState.berryBushes.set(currentTileKey, 'barren1');
                        gameState.bushesGatheredToday.add(currentTileKey);
                        gatheredFromBush = true;
                    }
                    // Barren bushes (barren1, barren2): ignore the bush, gather normally, let it regenerate
                }
                
                // If didn't gather from bush (no bush, or barren bush), use regular gathering
                if (!gatheredFromBush) {
                    foodFound = Math.floor(Math.random() * 3);
                }
                
                // Add to food storage (capped at 99)
                gameState.food = Math.min(99, gameState.food + foodFound);
                
                // Show modal
                document.getElementById('modal-message').textContent = `You've found ${foodFound} units of food!`;
                document.getElementById('modal-overlay').classList.add('active');
                
                // Update display to show new food count
                updateDisplay();
            }
        });

        document.getElementById('explore').addEventListener('click', () => {
            if (!gameState.isExploring) {
                gameState.isExploring = true;
                // Tired players only get 1 move
                gameState.movesRemaining = character.tired ? 1 : 2;
                document.getElementById('map-panel').classList.add('exploring');
                updateDisplay();
            }
        });

        // Function to reset the game
        function resetGame() {
            // Reset character
            character.hp = 4;
            character.fp = 4;
            character.inventory = [null, null, null];
            character.tired = false;
            
            // Reset game state
            gameState.day = 1;
            gameState.visitedTiles.clear();
            gameState.seenTiles.clear();
            gameState.shelters.clear();
            gameState.naturalShelters.clear();
            gameState.bushesGatheredToday.clear();
            gameState.isExploring = false;
            gameState.movesRemaining = 0;
            gameState.food = 0;
            gameState.hasSeenTiredMessage = false;
            
            // Generate new random seed for new island shape
            islandSeed = Math.random() * 100000;
            
            // Regenerate island
            gameState.landTiles = generateIsland();
            
            // Find valid starting position
            function findValidStartPositionReset() {
                // Find nearest land tile from bottom-left (but not on border)
                for (let col = 1; col < gameState.mapSize - 1; col++) {
                    for (let row = gameState.mapSize - 2; row >= 1; row--) {
                        const key = getTileKey(row, col);
                        if (gameState.landTiles.has(key)) {
                            return { row, col };
                        }
                    }
                }
                
                // Fallback: find any land tile (not on border)
                for (const key of gameState.landTiles) {
                    const [row, col] = key.split(',').map(Number);
                    if (row > 0 && row < gameState.mapSize - 1 && 
                        col > 0 && col < gameState.mapSize - 1) {
                        return { row, col };
                    }
                }
                
                return { row: 8, col: 8 }; // Ultimate fallback (center)
            }
            
            const startPos = findValidStartPositionReset();
            character.position = startPos;
            gameState.visitedTiles.add(getTileKey(startPos.row, startPos.col));
            
            // Reveal surrounding tiles at start
            revealSurroundingTiles(startPos.row, startPos.col);
            
            // Reinitialize natural shelters and berry bushes
            initializeNaturalShelters();
            initializeBerryBushes();
            
            // Clear exploration UI
            document.getElementById('map-panel').classList.remove('exploring');
            document.getElementById('moves-remaining').style.display = 'none';
            
            // Hide game over screen if showing
            document.getElementById('game-over-overlay').classList.remove('active');
            
            // Update display
            updateDisplay();
        }

        // Reset button handler
        document.getElementById('reset-button').addEventListener('click', () => {
            resetGame();
        });
        
        // Try again button handler
        document.getElementById('try-again').addEventListener('click', () => {
            resetGame();
        });
        
        // Tired Ok button handler
        document.getElementById('tired-ok').addEventListener('click', () => {
            document.getElementById('tired-overlay').classList.remove('active');
        });

        // Eat button handler
        document.getElementById('eat-circle').addEventListener('click', () => {
            if (gameState.food > 0 && character.fp < 4) {
                gameState.food--;
                character.fp = Math.min(4, character.fp + 1);
                updateDisplay();
            }
        });

        // Modal Ok button handler
        document.getElementById('modal-ok').addEventListener('click', () => {
            // Hide modal
            document.getElementById('modal-overlay').classList.remove('active');
            
            passDayAndCheckDeath();
        });

        // Initialize display
        updateDisplay();
    </script>
</body>
</html>

